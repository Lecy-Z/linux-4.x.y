## barrier

现代编译器和处理器试图从代码中“压榨”出每一点性能，读者当然会认为这是好事情。但类似于每一件好事情，我们同样需要考虑其缺点（前面也有类似的情况）。一个有利于提高性能的技术是指令重排。只要结果不变，这完全没有问题。但编译器或处理器很难判定重排的结果是否确实与代码原本的意图匹配，特别是需要考虑副效应的时候，因此这种事情机器很自然不是人的对手。但在数据写入I/O寄存器时，副效应是常见且必要的。
尽管锁足以确保原子性，但对编译器和处理器优化过的代码，锁不能永远保证时序正确。与竞态条件相比，这个问题不仅影响SMP系统，也影响单处理器计算机。

内核提供了下面几个函数，可阻止处理器和编译器进行代码重排。

* mb()、rmb()、wmb()将硬件内存屏障插入到代码流程中。rmb()是读访问内存屏障。它保证在屏障之后发出的任何读取操作执行之前，屏障之前发出的所有读取操作都已经完成。wmb适用于写访问，语义与rmb类似。读者应该能猜到，mb()合并了二者的语义。
* barrier插入一个优化屏障。该指令告知编译器，保存在CPU寄存器中、在屏障之前有效的所有内存地址，在屏障之后都将失效。本质上，这意味着编译器在屏障之前发出的读写请求完成之前，不会处理屏障之后的任何读写请求。但CPU仍然可以重排时序！
* smb_mb()、smp_rmb()、smp_wmb()相当于上述的硬件内存屏障，但只用于SMP系统。它们在单处理器系统上产生的是软件屏障。
* read_barrier_depends()是一种特殊形式的读访问屏障，它会考虑读操作之间的依赖性。如果屏障之后的读请求，依赖于屏障之前执行的读请求的数据，那么编译器和硬件都不能重排这些请求。

请注意：上文给出的所有命令都会影响运行时的性能。这是很自然的，与开启优化时相比，停用优化后程序的速度会减慢，这也是优化代码的目的所在。大多数读者都会同意，运行稍慢但工作正确的代码，比快而出错的代码要好。优化屏障的一个特定应用是内核抢占机制。要注意，pre-empt_disable对抢占计数器加1因而停用了抢占，preempt_en-able通过对抢占计数器减1而再次启用抢占。这两个命令之间的代码，可免受抢占的影响。

看一看下列代码：

```
preempt_disable();
function_which_must_not_be_preempted();
preempt_enable()
```

如果编译器决定将代码重新排序如下，那么就相当麻烦了：

```
function_which_must_not_be_preempted();
preempt_disable();
preempt_enable();
```

这上述情况下，不可抢占的部分都会变得可抢占。因此，preempt_disable在抢占计数器加1之后插入一个内存屏障：

```
#define preempt_disable() \
do { \
    inc_preempt_count(); \
    barrier(); \
} while (0)
```

这防止了编译器将inc_preempt_count()与后续的语句交换位置。同样，preempt_enable必须在再次启用抢占之前插入一个优化屏障：

```
#define preempt_enable() \
do {   \
  ...
  barrier(); \
  preempt_check_resched(); \
} while (0)
```

这种措施可以防止上文给出的第二种错误的重排。