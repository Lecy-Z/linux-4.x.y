Process
========================================

传统上，UNIX操作系统下运行的应用程序、服务器及其他程序都称为进程。每个进程都在CPU的虚拟内存中分配
地址空间。各个进程的地址空间是完全独立的，因此进程并不会意识到彼此的存在。从进程的角度来看，它会
认为自己是系统中唯一的进程。如果进程想要彼此通信（例如交换数据），那么必须使用特定的内核机制。由于
Linux是多任务系统，它支持（看上去）并发执行的若干进程。系统中同时真正在运行的进程数目最多不超过CPU
数目，因此内核会按照短的时间间隔在不同的进程之间切换（用户是注意不到的）

常用名词
----------------------------------------

### 进程

Linux对进程采用了一种层次系统，每个进程都依赖于一个父进程。内核启动init程序作为第一个进程，
该进程负责进一步的系统初始化操作，并显示登录提示符或图形登录界面（现在使用比较广泛）。因此
init是进程树的根，所有进程都直接或间接起源自该进程.

UNIX操作系统中有两种创建新进程的机制，分别是fork和exec。

* fork

可以创建当前进程的一个副本，父进程和子进程只有PID（进程ID）不同。在该系统调用执行之后，
系统中有两个进程，都执行同样的操作。父进程内存的内容将被复制，至少从程序的角度来看是这样。Linux
使用了一种众所周知的技术来使fork操作更高效，该技术称为写时复制（copy on write），主要的原理是将
内存复制操作延迟到父进程或子进程向某内存页面写入数据之前，在只读访问的情况下父进程和子进程可以共用
同一内存页。例如，使用fork的一种可能的情况是，用户打开另一个浏览器窗口。如果选中了对应的选项，
浏览器将执行fork，复制其代码，接下来子进程中将启动适当的操作建立新窗口。

* exec

将一个新程序加载到当前进程的内存中并执行。旧程序的内存页将刷出，其内容将替换为新的数据。然后开始执行新程序。

### 线程

进程并不是内核支持的唯一一种程序执行形式。除了重量级进程（有时也称为UNIX进程）之外，还有一种形式
是线程（有时也称为轻量级进程）。线程也已经出现相当长的一段时间，本质上一个进程可能由若干线程组成，
这些线程共享同样的数据和资源，但可能执行程序中不同的代码路径。线程概念已经完全集成到许多现代编程
语言中，例如Java。简而言之，进程可以看作一个正在执行的程序，而线程则是与主程序并行运行的程序
函数或例程。该特性是有用的，例如在浏览器需要并行加载若干图像时。通常浏览器只好执行几次fork和exec
调用，以此创建若干并行的进程实例。这些进程负责加载图像，并使用某种通信机制将接收的数据提供给主程序。
在使用线程时，这种情况更容易处理一些。浏览器定义了一个例程来加载图像，可以将例程作为线程启动，
使用参数不同的多个线程即可。由于线程和主程序共享同样的地址空间，主程序自动就可以访问接收到的数据。
因此除了为防止线程访问同一内存区而采取的互斥机制外，就不需要什么通信了。

Linux用clone方法创建线程。其工作方式类似于fork，但启用了精确的检查，以确认哪些资源与父进程共享、
哪些资源为线程独立创建。这种细粒度的资源分配扩展了一般的线程概念，在一定程度上允许线程与进程之间
的连续转换。

### 命名空间

https://github.com/novelinux/linux-4.x.y/tree/master/include/linux/nsproxy.h/README.md

### 地址空间

https://github.com/novelinux/linux-4.x.y/blob/master/mm/mmap.c/README.md

### 特权级别

内核把虚拟地址空间划分为两个部分，因此能够保护各个系统进程，使之彼此隔离。所有的现代CPU
都提供了几种特权级别，进程可以驻留在某一特权级别。每个特权级别都有各种限制，例如对执行
某些汇编语言指令或访问虚拟地址空间某一特定部分的限制。IA-32体系结构使用4种特权级别构成的系统，
各级别可以看作是环。内环能够访问更多的功能，外环则较少，如图所示:

https://github.com/novelinux/linux-4.x.y/tree/master/kernel/res/privilege.png

尽管英特尔处理器区分4种特权级别，但Linux只使用两种不同的状态：核心态和用户状态。
两种状态的关键差别在于对高于TASK_SIZE的内存区域的访问。简而言之，在用户状态禁止访问内核空间。
用户进程不能操作或读取内核空间中的数据，也无法执行内核空间中的代码。这是内核的专用领域。
这种机制可防止进程无意间修改彼此的数据而造成相互干扰。从用户状态到核心态的切换通过系统调用
的特定转换手段完成，且系统调用的执行因具体系统而不同。如果普通进程想要执行任何影响整个系统
的操作（例如操作输入/输出装置），则只能借助于系统调用向内核发出请求。内核首先检查进程是否
允许执行想要的操作，然后代表进程执行所需的操作，接下来返回到用户状态。除了代表用户程序执行
代码之外，内核还可以由异步硬件中断激活，然后在中断上下文中运行。与在进程上下文中运行的主要
区别是，在中断上下文中运行不能访问虚拟地址空间中的用户空间部分。因为中断可能随机发生，中断
发生时可能是任一用户进程处于活动状态，由于该进程基本上与中断的原因无关，因此内核无权访问当前
用户空间的内容。在中断上下文中运行时，内核必须比正常情况更加谨慎，例如，不能进入睡眠状态。
在编写中断处理程序时需要特别注意这些.

除了普通进程，系统中还有内核线程在运行。内核线程也不与任何特定的用户空间进程相关联，因此也
无权处理用户空间。不过在其他许多方面，内核线程更像是普通的用户层应用程序。与在中断上下文运转
的内核相比，内核线程可以进入睡眠状态，也可以像系统中的普通进程一样被调度器跟踪。内核线程可用
于各种用途：从内存和块设备之间的数据同步，到帮助调度器在CPU上分配进程。在多处理器系统上，
许多线程启动时指定了CPU，并限制只能在某个特定的CPU上运行。从内核线程名称之后的斜线和CPU编号可以
看到这一点。

进程生命周期
----------------------------------------

进程并不总是可以立即运行。有时候它必须等待来自外部信号源、不受其控制的事件，例如在文本编辑器
中等待键盘输入。在事件发生之前，进程无法运行。当调度器在进程之间切换时，必须知道系统中每个进程
的状态。将CPU时间分配到无事可做的进程，显然是没有意义的。进程在各个状态之间的转换也同样重要。
例如，如果一个进程在等待来自外设的数据，那么调度器的职责是一旦数据已经到达，则需要将进程的状态
由等待改为可运行。进程可能有以下几种状态。

* 运行: 该进程此刻正在执行。

* 等待: 进程能够运行，但没有得到许可，因为CPU分配给另一个进程。调度器可以在下一次任务切换时选择该进程。

* 睡眠: 进程正在睡眠无法运行，因为它在等待一个外部事件。调度器无法在下一次任务切换时选择该进程。

系统将所有进程保存在一个进程表中，无论其状态是运行、睡眠或等待。但睡眠进程会特别标记出来，
调度器会知道它们无法立即运行。睡眠进程会分类到若干队列中，因此它们可在适当的时间唤醒，
例如在进程等待的外部事件已经发生时。下图描述了进程的几种状态及其转换。

https://github.com/novelinux/linux-4.x.y/tree/master/kernel/res/task_state.png

对于一个排队中的可运行进程，我们来考察其各种可能的状态转换。该进程已经就绪，但没有运行，
因为CPU分配给了其他进程（因此该进程的状态是“等待”）。在调度器授予CPU时间之前，进程会一直
保持该状态。在分配CPU时间之后，其状态改变为“运行”（路径④）。在调度器决定从该进程收回CPU资源时，
进程状态从“运行”改变为“等待”（路径②），循环重新开始。实际上根据是否可以被信号中断，有两种
“睡眠”状态。现在这种差别还不重要，但在更仔细地考察具体实现时，其差别就相对重要了。如果进程必须
等待事件，则其状态从“运行”改变为“睡眠”（路径①）。但进程状态无法从“睡眠”直接改变为“运行”。
在所等待的事件发生后，进程先变回到“等待”状态（路径③），然后重新回到正常循环。
在程序执行终止（例如，用户关闭应用程序）后，过程状态由“运行”变为“终止”（路径⑤）。

上文没有列出的一个特殊的进程状态是所谓的“僵尸”状态。顾名思义，这样的进程已经死亡，但仍然以某种
方式活着。实际上，说这些进程死了，是因为其资源（内存、与外设的连接，等等）已经释放，因此它们
无法也决不会再次运行。说它们仍然活着，是因为进程表中仍然有对应的表项。

其原因在于UNIX操作系统下进程创建和销毁的方式。在两种事件发生时，程序将终止运行。

第一，程序必须由另一个进程或一个用户杀死（通常是通过发送SIGTERM或SIGKILL信号来完成，
这等价于正常地终止进程）;进程的父进程在子进程终止时必须调用或已经调用wait4（读做wait for）
系统调用。这相当于向内核证实父进程已经确认子进程的终结。该系统调用使得内核可以释放为子进程
保留的资源。只有在第一个条件发生（程序终止）而第二个条件不成立的情况下（wait4），
才会出现“僵尸”状态。在进程终止之后，其数据尚未从进程表删除之前，进程总是暂时处于“僵尸”状态。
有时候（例如，如果父进程编程极其糟糕，没有发出wait调用），僵尸进程可能稳定地寄身于进程表中，
直至下一次系统重启。从进程工具（如ps或top）的输出，可以看到僵尸进程。因为残余的数据在内核中
占据的空间极少，所有这几乎不是一个问题。

### Linux进程的睡眠和唤醒

在Linux中，仅等待CPU时间的进程称为就绪进程，它们被放置在一个运行队列中，一个就绪进程的状态标志位为TASK_RUNNING。一旦一个运行中的进程时间片用完， Linux 内核的调度器会剥夺这个进程对CPU的控制权，并且从运行队列中选择一个合适的进程投入运行。

当然，一个进程也可以主动释放CPU的控制权。函数 schedule()是一个调度函数，它可以被一个进程主动调用，从而调度其它进程占用CPU。一旦这个主动放弃CPU的进程被重新调度占用 CPU，那么它将从上次停止执行的位置开始执行，也就是说它将从调用schedule()的下一行代码处开始执行。

有时候，进程需要等待直到某个特定的事件发生，例如设备初始化完成、I/O 操作完成或定时器到时等。在这种情况下，进程则必须从运行队列移出，加入到一个等待队列中，这个时候进程就进入了睡眠状态。

#### Linux 中的进程睡眠状态有两种：

一种是可中断的睡眠状态，其状态标志位TASK_INTERRUPTIBLE；

另一种是不可中断的睡眠状态，其状态标志位为TASK_UNINTERRUPTIBLE。可中断的睡眠状态的进程会睡眠直到某个条件变为真，比如说产生一个硬件中断、释放 进程正在等待的系统资源或是传递一个信号都可以是唤醒进程的条件。不可中断睡眠状态与可中断睡眠状态类似，但是它有一个例外，那就是把信号传递到这种睡眠 状态的进程不能改变它的状态，也就是说它不响应信号的唤醒。不可中断睡眠状态一般较少用到，但在一些特定情况下这种状态还是很有用的，比如说：进程必须等待，不能被中断，直到某个特定的事件发生。

在现代的Linux操作系统中，进程一般都是用调用schedule()的方法进入睡眠状态的，下面的代码演示了如何让正在运行的进程进入睡眠状态。

```
　　sleeping_task = current;
　　set_current_state(TASK_INTERRUPTIBLE);
　　schedule();
　　func1();
　　/ Rest of the code ... /
```

在第一个语句中，程序存储了一份进程结构指针sleeping_task，current 是一个宏，它指向正在执行的进程结构。set_current_state()将该进程的状态从执行状态TASK_RUNNING 变成睡眠状态TASK_INTERRUPTIBLE。 如果schedule()是被一个状态为TASK_RUNNING 的进程调度，那么schedule()将调度另外一个进程占用CPU；如果schedule()是被一个状态为TASK_INTERRUPTIBLE 或TASK_UNINTERRUPTIBLE 的进程调度，那么还有一个附加的步骤将被执行：当前执行的进程在另外一个进程被调度之前会被从运行队列中移出，这将导致正在运行的那个进程进入睡眠，因为它已经不在运行队列中了。
我们可以使用下面的这个函数将刚才那个进入睡眠的进程唤醒。

```
　　wake_up_process(sleeping_task);
```

在调用了wake_up_process()以后，这个睡眠进程的状态会被设置为TASK_RUNNING，而且调度器会把它加入到运行队列中去。当然，这个进程只有在下次被调度器调度到的时候才能真正地投入运行。

Data Structure
----------------------------------------

### struct task_struct

Linux内核涉及进程和程序的所有算法都围绕一个名为task_struct的数据结构建立，该结构定义如下所示:

https://github.com/novelinux/linux-4.x.y/tree/master/include/linux/sched.h/struct_task_struct.md

### struct thread_info

#### ARM

https://github.com/novelinux/linux-4.x.y/blob/master/arch/arm/include/asm/thread_info.h/struct_thread_info.md

### union thread_union

https://github.com/novelinux/linux-4.x.y/tree/master/include/linux/sched.h/union_thread_union.md

task_struct, thread_info和kernel stack之间关系:

https://github.com/novelinux/linux-4.x.y/tree/master/include/linux/sched.h/res/task_struct-thread_info-stack.jpg

init_task
----------------------------------------

init_task在Linux系统中，只有这个进程是静态分配的:

https://github.com/novelinux/linux-4.x.y/tree/master/init/init_task.c/README.md

Create
----------------------------------------

### fork

https://github.com/novelinux/system_calls/blob/master/fork.md

### kernel_thread

https://github.com/novelinux/linux-4.x.y/tree/master/kernel/fork.c/kernel_thread.md

* kthreadd

https://github.com/novelinux/linux-4.x.y/tree/master/init/main.c/rest_init.md

Schedule
----------------------------------------

https://github.com/novelinux/linux-4.x.y/tree/master/kernel/sched/core.c/__schedule.md

Execute
----------------------------------------

https://github.com/novelinux/linux-4.x.y/tree/master/fs/exec.c/README.md
