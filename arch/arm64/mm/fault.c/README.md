## 缺页异常的处理

在实际需要某个虚拟内存区域的数据之前，虚拟和物理内存之间的关联不会建立。如果进程访问的虚拟地址空间部分尚未与页帧关联，
处理器自动地引发一个缺页异常，内核必须处理此异常。这是内存管理中最重要、最复杂的方面之一，因为必须考虑到无数的细节。例如，内核必须确定以下情况。

* 缺页异常是由于访问用户地址空间中的有效地址而引起，还是应用程序试图访问内核的受保护区域？
* 目标地址对应于某个现存的映射吗？
* 获取该区域的数据，需要使用何种机制？

[Page Faults](./basic_flow.jpeg)给出了内核在处理缺页异常时，可能使用的各种代码路径的一个粗略的概观。
按下文的讲述，实际上各个操作都要复杂得多，因为内核不仅要防止来自用户空间的恶意访问，还要注意许多细枝末节。
此外，决不能因为缺页处理的相关操作而不必要地降低系统性能。缺页处理的实现因处理器的不同而有所不同。由于CPU
采用了不同的内存管理概念，生成缺页异常的细节也不太相同。因此，缺页异常的处理例程在内核代码中位于特定于体系结构的部分。

缺页异常的入口do_page_fault例程的代码流程图。

[do_page_fault](./do_page_fault.jpeg)

### do_page_fault

do_page_fault是缺页中断的核心函数，主要工作交给__do_page_fault处理，然后进行一些异常处理__do_kernel_fault和__do_user_fault。

__do_page_fault查找合适的vma，然后主要工作交给handle_mm_fault；handle_mm_fault的核心又是handle_pte_fault。

handle_pte_fault中根据也是否存在分为两类：do_fault(文件映射缺页中断)、do_anonymous_page(匿名页面缺页中断)、do_swap_page()和do_wp_page(写时复制)。

[do_page_fault codes](do_page_fault.md)