## BPFd：跨系统和体系结构远程运行BCC工具

BPF是一种功能越来越强大的工具，用于检测和跟踪内核的运行。它使创建越来越多的BCC工具集成为可能。不幸的是，BCC不支持跨开发工作流，在跨工作流中，开发机器和运行所开发代码的目标机器是不同的。交叉开发受到嵌入式系统内核开发人员的青睐，他们倾向于在x86主机上进行开发，然后在基于ARM架构的SoC（片上系统）上进行闪存和测试代码。在本文中，我介绍了BPFd，这是一个使用BPF和BCC进行交叉开发的项目。

BPF编译器集合（BCC）是一套内核跟踪工具，可让系统工程师高效，安全地深入了解Linux系统的内部工作原理。因为它们不能使内核崩溃，所以它们比内核模块更安全，可以在生产中使用。布伦丹·格雷格（Brendan Gregg）写了一些不错的工具，并进行了演讲，展示了基于eBPF的工具的全部功能。另请参见在LWN上发布的BCC简介。

在Android内核小组中，由于大多数Android设备都使用此架构，因此我们主要在ARM64系统上工作。多年来，ARM64系统上的BCC工具支持已经中断。造成此困难的原因之一是使用ARM64内联汇编程序语句。不可避免地，BCC工具中包含的内核标头导致包含特定于体系结构的标头，在ARM64的情况下，该标头有可能产生内联ARM64汇编指令，从而给LLVM的BPF后端带来很大麻烦。最近，通过向编译器添加BPF内联程序集支持（这些LLVM提交）解决了该问题，人们最终可以在ARM64上运行BCC工具，但这并不是唯一的问题。

为了使BCC工具完全起作用，它们需要内核源代码。这是因为大多数工具都需要在不断变化的内核API上注册回调以获取其数据。此类回调使用kprobe基础结构进行注册。运行BCC工具时，BCC在编译开始之前将其当前目录切换到内核源目录，然后编译BCC工具逻辑的C程序。 C程序免费包含内核头文件，以使kprobes可以工作并使用内核数据结构。

即使不使用kprobes，BCC也会隐式添加一个公共helper.h include指令，只要编译eBPF C程序即可。该文件可在BCC源中的src/cc/export/helpers.h中找到。该头使用LINUX_VERSION_CODE宏在编译的输出中创建“版本”部分。 LINUX_VERSION_CODE仅在所针对的特定内核的源代码中可用；在eBPF程序加载期间使用它来确保将BPF程序加载到具有正确版本的内核中。如您所见，内核源代码很快成为编译eBPF程序的必需条件。

从某种意义上讲，此构建过程类似于构建外部内核模块的过程。内核源的大小很大，并且通常会在正在调试的系统上占用大量空间。它们也可能不同步，这可能会使工具行为不当。

另一个问题是Clang和LLVM库需要在要跟踪的目标上可用，因为这些工具会编译所需的BPF字节码，然后将其加载到内核中。这些库占用大量空间。当BPF代码可以在其他地方编译甚至可能只编译一次时，您似乎需要在系统上使用完善的编译器基础结构，这似乎有点过头了。此外，这些库需要交叉编译以在您要跟踪的体系结构上运行。那是可能的，但是如果有人不需要的话，为什么有人要这么做呢？交叉编译的编译器工具链可能既繁琐又压力很大。

我没有将所有工具，编译器基础结构和内核源加载到要跟踪的远程目标上并以此方式运行BCC，而是决定编写一个名为BPFd的代理程序，该程序接收命令并代表请求它们的人执行命令。所有繁重的工作（编译，用户输入解析，哈希映射解析，结果呈现等）都是由主机上的BCC工具完成的，而BPFd在目标计算机上作为目标内核的接口运行。 BPFd封装并满足了BCC的所有需求；这包括加载BPF程序，创建，删除和查找map，将eBPF程序附加到kprobe，轮询eBPF程序可能已写入perf缓冲区的新数据，等等。如果由于perf缓冲区包含而被唤醒新数据，它将通知主机上的BCC工具，也可以在需要时返回地图数据，其中可能包含目标eBPF程序更新的信息。

### 设计简单

在开始这项工作之前，BCC工具架构如下：

[BCC Arch](./bcc-arch.png)

基于BPFd的调用对这种体系结构进行了划分，从而可以跨机器和体系结构边界进行工具的交叉开发和执行。 例如，BCC工具所依赖的内核源可以在开发机器上，而eBPF代码被加载到远程机器上。

[BCC With Bpfd Arch](./bcc-with-bpfd-arch.png)

BPFd的设计非常简单，它期望在stdin（标准输入）上有命令，并在stdout（标准输出）上提供结果。无论命令多大，每个命令都是一行。这使使用cat的测试变得容易，因为可以简单地使用命令对文件进行cat，并检查BPFd的stdout是否包含预期的结果。命令的结果可以是多行。

BPF映射是BPF程序用于存储数据的数据结构，可以在以后检索该数据结构。映射成功创建后，由bpf（）系统调用返回的文件描述符表示。例如，以下是BPFd创建BPF哈希表映射的命令：

```
BPF_CREATE_MAP 1 count 8 40 10240 0
```

BPFd的结果是：

```
bpf_create_map：ret = 3
```

由于BPFd代理了映射创建，因此文件描述符（本示例中为3）被映射到BPFd的文件描述符表中。该命令告诉BPFd创建一个名为count的映射，其映射类型为1（哈希表），密钥大小为8个字节，值大小为40，最多10240个条目，并且没有特殊标志。作为响应，BPFd创建了一个由文件描述符3标识的映射。

使用标准输入/输出设计，可以在BPFd周围编写包装器，以处理更高级的通信方法，例如USB或网络。作为我在Android内核团队中进行分析的一部分，我正在通过Android调试桥（adb）传达这些命令，该调试桥通过USB或TCP / IP与目标设备连接。我在下面分享了几个演示。

### BCC工具的变更

为了使BCC工具库能够与BPFd一起使用，已对其进行了许多更改。这里描述了一些更重要的变化。这些更改可以在BPFd存储库的此分支中找到。

BCC工具中已添加了新的远程模块，其抽象是必须实现不同的远程访问类型（例如网络或USB）。这样可以使代码重复最少。通过实现远程所需的功能，可以轻松添加新的通信方法。当前提供了adb​​远程和进程远程。 adb使用Android调试桥通过USB或TCP / IP与目标设备进行通信。使用远程进程（这可能仅对本地测试有用），将BPFd分叉到运行BCC的同一台计算机上，并通过stdin和stdout与之通信。

libbpf.c是BCC项目中的主要C文件，它与内核讨论BPF的所有内容。上图对此进行了说明。为了使BCC在远程计算机而不是本地计算机上执行BPF操作，现在将对本地libbpf.c进行调用的BCC部分引导到目标上的远程BPFd。然后，目标上的BPFd通过调用其libbpf.c副本来代表本地运行的BCC执行命令。

进行这项工作的棘手部分之一是，某些其他路径也需要引导到远程计算机。例如，要附加到跟踪点，BCC需要系统上所有可用跟踪点的列表。该列表必须在远程系统上获得，并且是BPFd中GET_TRACE_EVENTS命令的原因。

当BCC将封装在BCC工具中的C程序编译为eBPF指令时，它假定eBPF程序将在运行BCC的同一处理器体系结构上运行。为其他目标构建eBPF程序时，这是不正确的。前一段时间，在我开始这个项目之前，我更改了构建内核内eBPF样本（这些样本是简单的独立样本，与BCC无关）的假设。现在，我不得不对BCC进行类似的更改，以便它可以为目标体系结构正确地编译C程序。

安装和运行
要自己尝试，请按照详细或简单的说明进行操作。另外，应用此内核补丁（当前已在上游提交）可以更快地运行offcputime之类的工具。

例如，考虑使用filetop，它是一个BCC工具，它向您显示所有读/写I / O操作，其体验与top工具相似。每隔几秒钟刷新一次，使您可以实时查看这些操作。要使用BPFd远程运行Filetop，请先进入BCC目录并设置所需的环境变量。如下所示：

## References

https://lwn.net/Articles/744522/